/* tslint:disable */
/* eslint-disable */
/**
 * Step Service API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * The response message containing the greetings
 * @export
 * @interface HelloworldV1HelloReply
 */
export interface HelloworldV1HelloReply {
    /**
     * 
     * @type {string}
     * @memberof HelloworldV1HelloReply
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface MinioV1GetDownloadPreSignedUrlReply
 */
export interface MinioV1GetDownloadPreSignedUrlReply {
    /**
     * 
     * @type {string}
     * @memberof MinioV1GetDownloadPreSignedUrlReply
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface MinioV1GetUploadPreSignedUrlReply
 */
export interface MinioV1GetUploadPreSignedUrlReply {
    /**
     * 
     * @type {string}
     * @memberof MinioV1GetUploadPreSignedUrlReply
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface StepV1AddTargetDirStepReply
 */
export interface StepV1AddTargetDirStepReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1AddTargetDirStepReply
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1AddTargetDirStepReply
     */
    'objectName'?: string;
}
/**
 * 
 * @export
 * @interface StepV1AddTargetDirStepRequest
 */
export interface StepV1AddTargetDirStepRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1AddTargetDirStepRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1AddTargetDirStepRequest
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface StepV1CreateTargetReply
 */
export interface StepV1CreateTargetReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1CreateTargetReply
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StepV1CreateTargetReply
     */
    'layer'?: number;
}
/**
 * 
 * @export
 * @interface StepV1CreateTargetRequest
 */
export interface StepV1CreateTargetRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1CreateTargetRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1CreateTargetRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1CreateTargetRequest
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1CreateTargetRequest
     */
    'parentId'?: string;
}
/**
 * 
 * @export
 * @interface StepV1DecryptReply
 */
export interface StepV1DecryptReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1DecryptReply
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface StepV1DecryptRequest
 */
export interface StepV1DecryptRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1DecryptRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1DecryptRequest
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface StepV1DeleteFeedbackAwardReply
 */
export interface StepV1DeleteFeedbackAwardReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1DeleteFeedbackAwardReply
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1DeleteTargetReply
 */
export interface StepV1DeleteTargetReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1DeleteTargetReply
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1DeleteTargetStepReply
 */
export interface StepV1DeleteTargetStepReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1DeleteTargetStepReply
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1DoneTargetReply
 */
export interface StepV1DoneTargetReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1DoneTargetReply
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1DoneTargetRequest
 */
export interface StepV1DoneTargetRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1DoneTargetRequest
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1EncryptReply
 */
export interface StepV1EncryptReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1EncryptReply
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface StepV1EncryptRequest
 */
export interface StepV1EncryptRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1EncryptRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1EncryptRequest
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface StepV1FeedbackAward
 */
export interface StepV1FeedbackAward {
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'description'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StepV1FeedbackAward
     */
    'settedFiles'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof StepV1FeedbackAward
     */
    'realizedFiles'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'targetType'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'dimension'?: string;
    /**
     * 
     * @type {number}
     * @memberof StepV1FeedbackAward
     */
    'threshold'?: number;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'settedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'achievedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1FeedbackAward
     */
    'realizedAt'?: string;
}
/**
 * 
 * @export
 * @interface StepV1GetFeedbackAwardReply
 */
export interface StepV1GetFeedbackAwardReply {
    /**
     * 
     * @type {StepV1FeedbackAward}
     * @memberof StepV1GetFeedbackAwardReply
     */
    'award'?: StepV1FeedbackAward;
}
/**
 * 
 * @export
 * @interface StepV1GetFeedbackAwardsReply
 */
export interface StepV1GetFeedbackAwardsReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1GetFeedbackAwardsReply
     */
    'total'?: string;
    /**
     * 
     * @type {Array<StepV1FeedbackAward>}
     * @memberof StepV1GetFeedbackAwardsReply
     */
    'awards'?: Array<StepV1FeedbackAward>;
}
/**
 * 
 * @export
 * @interface StepV1GetNoauthStepReply
 */
export interface StepV1GetNoauthStepReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1GetNoauthStepReply
     */
    'targetTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1GetNoauthStepReply
     */
    'targetDescription'?: string;
    /**
     * 
     * @type {StepV1Step}
     * @memberof StepV1GetNoauthStepReply
     */
    'step'?: StepV1Step;
    /**
     * 
     * @type {Array<StepV1Step>}
     * @memberof StepV1GetNoauthStepReply
     */
    'children'?: Array<StepV1Step>;
}
/**
 * 
 * @export
 * @interface StepV1GetPortraitBasicReply
 */
export interface StepV1GetPortraitBasicReply {
    /**
     * basic, self_discipline, target_and_execution, learning_and_growth
     * @type {string}
     * @memberof StepV1GetPortraitBasicReply
     */
    'dimension'?: string;
    /**
     * json string
     * @type {string}
     * @memberof StepV1GetPortraitBasicReply
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface StepV1GetPortraitStepRateReply
 */
export interface StepV1GetPortraitStepRateReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1GetPortraitStepRateReply
     */
    'topTargetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1GetPortraitStepRateReply
     */
    'statUnit'?: string;
    /**
     * json string
     * @type {string}
     * @memberof StepV1GetPortraitStepRateReply
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface StepV1GetTargetDirStepChildrenReply
 */
export interface StepV1GetTargetDirStepChildrenReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1GetTargetDirStepChildrenReply
     */
    'total'?: string;
    /**
     * 
     * @type {Array<StepV1Step>}
     * @memberof StepV1GetTargetDirStepChildrenReply
     */
    'steps'?: Array<StepV1Step>;
}
/**
 * 
 * @export
 * @interface StepV1GetTargetReply
 */
export interface StepV1GetTargetReply {
    /**
     * 
     * @type {StepV1Target}
     * @memberof StepV1GetTargetReply
     */
    'target'?: StepV1Target;
    /**
     * 
     * @type {string}
     * @memberof StepV1GetTargetReply
     */
    'total'?: string;
    /**
     * 
     * @type {Array<StepV1Step>}
     * @memberof StepV1GetTargetReply
     */
    'steps'?: Array<StepV1Step>;
}
/**
 * 
 * @export
 * @interface StepV1GetTargetTreeReply
 */
export interface StepV1GetTargetTreeReply {
    /**
     * 
     * @type {StepV1Target}
     * @memberof StepV1GetTargetTreeReply
     */
    'rootTarget'?: StepV1Target;
}
/**
 * 
 * @export
 * @interface StepV1GetTargetsReply
 */
export interface StepV1GetTargetsReply {
    /**
     * 
     * @type {Array<StepV1Target>}
     * @memberof StepV1GetTargetsReply
     */
    'targets'?: Array<StepV1Target>;
}
/**
 * 
 * @export
 * @interface StepV1SetCommentForStepReply
 */
export interface StepV1SetCommentForStepReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1SetCommentForStepReply
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1SetCommentForStepRequest
 */
export interface StepV1SetCommentForStepRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1SetCommentForStepRequest
     */
    'id'?: string;
    /**
     * teacher, parent, friend
     * @type {string}
     * @memberof StepV1SetCommentForStepRequest
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1SetCommentForStepRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface StepV1Step
 */
export interface StepV1Step {
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StepV1Step
     */
    'isChallenge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'objectName'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'presignedUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'refTargetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'teacherComment'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'parentComment'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Step
     */
    'friendComment'?: string;
}
/**
 * 
 * @export
 * @interface StepV1Target
 */
export interface StepV1Target {
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'startAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'challengeAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'doneAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof StepV1Target
     */
    'layer'?: number;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1Target
     */
    'targetParent'?: string;
    /**
     * 
     * @type {Array<StepV1Target>}
     * @memberof StepV1Target
     */
    'children'?: Array<StepV1Target>;
}
/**
 * 
 * @export
 * @interface StepV1UpdateTargetReply
 */
export interface StepV1UpdateTargetReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetReply
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1UpdateTargetRequest
 */
export interface StepV1UpdateTargetRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetRequest
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface StepV1UpdateTargetStepReply
 */
export interface StepV1UpdateTargetStepReply {
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetStepReply
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface StepV1UpdateTargetStepRequest
 */
export interface StepV1UpdateTargetStepRequest {
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetStepRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetStepRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetStepRequest
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StepV1UpdateTargetStepRequest
     */
    'isChallenge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StepV1UpdateTargetStepRequest
     */
    'type'?: string;
}

/**
 * FeedbackServiceApi - axios parameter creator
 * @export
 */
export const FeedbackServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackServiceDeleteFeedbackAward: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('feedbackServiceDeleteFeedbackAward', 'id', id)
            const localVarPath = `/feedback/award/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackServiceGetFeedbackAward: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('feedbackServiceGetFeedbackAward', 'id', id)
            const localVarPath = `/feedback/award/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [status] 
         * @param {string} [settedStartDate] 
         * @param {string} [settedEndDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackServiceGetFeedbackAwards: async (page?: number, pageSize?: number, status?: string, settedStartDate?: string, settedEndDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/feedback/awards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (settedStartDate !== undefined) {
                localVarQueryParameter['settedStartDate'] = settedStartDate;
            }

            if (settedEndDate !== undefined) {
                localVarQueryParameter['settedEndDate'] = settedEndDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackServiceApi - functional programming interface
 * @export
 */
export const FeedbackServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbackServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedbackServiceDeleteFeedbackAward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1DeleteFeedbackAwardReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedbackServiceDeleteFeedbackAward(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedbackServiceApi.feedbackServiceDeleteFeedbackAward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedbackServiceGetFeedbackAward(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetFeedbackAwardReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedbackServiceGetFeedbackAward(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedbackServiceApi.feedbackServiceGetFeedbackAward']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [status] 
         * @param {string} [settedStartDate] 
         * @param {string} [settedEndDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedbackServiceGetFeedbackAwards(page?: number, pageSize?: number, status?: string, settedStartDate?: string, settedEndDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetFeedbackAwardsReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedbackServiceGetFeedbackAwards(page, pageSize, status, settedStartDate, settedEndDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedbackServiceApi.feedbackServiceGetFeedbackAwards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedbackServiceApi - factory interface
 * @export
 */
export const FeedbackServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbackServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackServiceDeleteFeedbackAward(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1DeleteFeedbackAwardReply> {
            return localVarFp.feedbackServiceDeleteFeedbackAward(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackServiceGetFeedbackAward(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetFeedbackAwardReply> {
            return localVarFp.feedbackServiceGetFeedbackAward(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {string} [status] 
         * @param {string} [settedStartDate] 
         * @param {string} [settedEndDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackServiceGetFeedbackAwards(page?: number, pageSize?: number, status?: string, settedStartDate?: string, settedEndDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetFeedbackAwardsReply> {
            return localVarFp.feedbackServiceGetFeedbackAwards(page, pageSize, status, settedStartDate, settedEndDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedbackServiceApi - object-oriented interface
 * @export
 * @class FeedbackServiceApi
 * @extends {BaseAPI}
 */
export class FeedbackServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackServiceApi
     */
    public feedbackServiceDeleteFeedbackAward(id: string, options?: RawAxiosRequestConfig) {
        return FeedbackServiceApiFp(this.configuration).feedbackServiceDeleteFeedbackAward(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackServiceApi
     */
    public feedbackServiceGetFeedbackAward(id: string, options?: RawAxiosRequestConfig) {
        return FeedbackServiceApiFp(this.configuration).feedbackServiceGetFeedbackAward(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {string} [status] 
     * @param {string} [settedStartDate] 
     * @param {string} [settedEndDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackServiceApi
     */
    public feedbackServiceGetFeedbackAwards(page?: number, pageSize?: number, status?: string, settedStartDate?: string, settedEndDate?: string, options?: RawAxiosRequestConfig) {
        return FeedbackServiceApiFp(this.configuration).feedbackServiceGetFeedbackAwards(page, pageSize, status, settedStartDate, settedEndDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GreeterApi - axios parameter creator
 * @export
 */
export const GreeterApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sends a greeting
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greeterSayHello: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('greeterSayHello', 'name', name)
            const localVarPath = `/helloworld/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GreeterApi - functional programming interface
 * @export
 */
export const GreeterApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GreeterApiAxiosParamCreator(configuration)
    return {
        /**
         * Sends a greeting
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async greeterSayHello(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelloworldV1HelloReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.greeterSayHello(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GreeterApi.greeterSayHello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GreeterApi - factory interface
 * @export
 */
export const GreeterApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GreeterApiFp(configuration)
    return {
        /**
         * Sends a greeting
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        greeterSayHello(name: string, options?: RawAxiosRequestConfig): AxiosPromise<HelloworldV1HelloReply> {
            return localVarFp.greeterSayHello(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GreeterApi - object-oriented interface
 * @export
 * @class GreeterApi
 * @extends {BaseAPI}
 */
export class GreeterApi extends BaseAPI {
    /**
     * Sends a greeting
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GreeterApi
     */
    public greeterSayHello(name: string, options?: RawAxiosRequestConfig) {
        return GreeterApiFp(this.configuration).greeterSayHello(name, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MinioApi - axios parameter creator
 * @export
 */
export const MinioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [downloadKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minioGetDownloadPreSignedUrl: async (downloadKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/minio/presigned/download_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (downloadKey !== undefined) {
                localVarQueryParameter['download_key'] = downloadKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [uploadKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minioGetUploadPreSignedUrl: async (uploadKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/minio/presigned/upload_url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (uploadKey !== undefined) {
                localVarQueryParameter['upload_key'] = uploadKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MinioApi - functional programming interface
 * @export
 */
export const MinioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MinioApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [downloadKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async minioGetDownloadPreSignedUrl(downloadKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinioV1GetDownloadPreSignedUrlReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.minioGetDownloadPreSignedUrl(downloadKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MinioApi.minioGetDownloadPreSignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [uploadKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async minioGetUploadPreSignedUrl(uploadKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MinioV1GetUploadPreSignedUrlReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.minioGetUploadPreSignedUrl(uploadKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MinioApi.minioGetUploadPreSignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MinioApi - factory interface
 * @export
 */
export const MinioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MinioApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [downloadKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minioGetDownloadPreSignedUrl(downloadKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<MinioV1GetDownloadPreSignedUrlReply> {
            return localVarFp.minioGetDownloadPreSignedUrl(downloadKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [uploadKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        minioGetUploadPreSignedUrl(uploadKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<MinioV1GetUploadPreSignedUrlReply> {
            return localVarFp.minioGetUploadPreSignedUrl(uploadKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MinioApi - object-oriented interface
 * @export
 * @class MinioApi
 * @extends {BaseAPI}
 */
export class MinioApi extends BaseAPI {
    /**
     * 
     * @param {string} [downloadKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MinioApi
     */
    public minioGetDownloadPreSignedUrl(downloadKey?: string, options?: RawAxiosRequestConfig) {
        return MinioApiFp(this.configuration).minioGetDownloadPreSignedUrl(downloadKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [uploadKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MinioApi
     */
    public minioGetUploadPreSignedUrl(uploadKey?: string, options?: RawAxiosRequestConfig) {
        return MinioApiFp(this.configuration).minioGetUploadPreSignedUrl(uploadKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PortraitServiceApi - axios parameter creator
 * @export
 */
export const PortraitServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portraitServiceGetPortraitBasic: async (dimension?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/portrait/basic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dimension !== undefined) {
                localVarQueryParameter['dimension'] = dimension;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [topTargetId] 
         * @param {string} [statUnit] day, week, month
         * @param {string} [startDate] format: 2025-01-01
         * @param {string} [endDate] format: 2025-01-01
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portraitServiceGetPortraitStepRate: async (topTargetId?: string, statUnit?: string, startDate?: string, endDate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/portrait/step_rate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (topTargetId !== undefined) {
                localVarQueryParameter['topTargetId'] = topTargetId;
            }

            if (statUnit !== undefined) {
                localVarQueryParameter['statUnit'] = statUnit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortraitServiceApi - functional programming interface
 * @export
 */
export const PortraitServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortraitServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portraitServiceGetPortraitBasic(dimension?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetPortraitBasicReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portraitServiceGetPortraitBasic(dimension, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortraitServiceApi.portraitServiceGetPortraitBasic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [topTargetId] 
         * @param {string} [statUnit] day, week, month
         * @param {string} [startDate] format: 2025-01-01
         * @param {string} [endDate] format: 2025-01-01
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portraitServiceGetPortraitStepRate(topTargetId?: string, statUnit?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetPortraitStepRateReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portraitServiceGetPortraitStepRate(topTargetId, statUnit, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PortraitServiceApi.portraitServiceGetPortraitStepRate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PortraitServiceApi - factory interface
 * @export
 */
export const PortraitServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortraitServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [dimension] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portraitServiceGetPortraitBasic(dimension?: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetPortraitBasicReply> {
            return localVarFp.portraitServiceGetPortraitBasic(dimension, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [topTargetId] 
         * @param {string} [statUnit] day, week, month
         * @param {string} [startDate] format: 2025-01-01
         * @param {string} [endDate] format: 2025-01-01
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portraitServiceGetPortraitStepRate(topTargetId?: string, statUnit?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetPortraitStepRateReply> {
            return localVarFp.portraitServiceGetPortraitStepRate(topTargetId, statUnit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortraitServiceApi - object-oriented interface
 * @export
 * @class PortraitServiceApi
 * @extends {BaseAPI}
 */
export class PortraitServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} [dimension] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortraitServiceApi
     */
    public portraitServiceGetPortraitBasic(dimension?: string, options?: RawAxiosRequestConfig) {
        return PortraitServiceApiFp(this.configuration).portraitServiceGetPortraitBasic(dimension, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [topTargetId] 
     * @param {string} [statUnit] day, week, month
     * @param {string} [startDate] format: 2025-01-01
     * @param {string} [endDate] format: 2025-01-01
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortraitServiceApi
     */
    public portraitServiceGetPortraitStepRate(topTargetId?: string, statUnit?: string, startDate?: string, endDate?: string, options?: RawAxiosRequestConfig) {
        return PortraitServiceApiFp(this.configuration).portraitServiceGetPortraitStepRate(topTargetId, statUnit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StepNoauthServiceApi - axios parameter creator
 * @export
 */
export const StepNoauthServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {StepV1DecryptRequest} stepV1DecryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepNoauthServiceDecrypt: async (id: string, stepV1DecryptRequest: StepV1DecryptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepNoauthServiceDecrypt', 'id', id)
            // verify required parameter 'stepV1DecryptRequest' is not null or undefined
            assertParamExists('stepNoauthServiceDecrypt', 'stepV1DecryptRequest', stepV1DecryptRequest)
            const localVarPath = `/apis/step-go-noauth/step/{id}/decrypt`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1DecryptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [shareTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepNoauthServiceGetNoauthStep: async (id: string, shareTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepNoauthServiceGetNoauthStep', 'id', id)
            const localVarPath = `/apis/step-go-noauth/step/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (shareTo !== undefined) {
                localVarQueryParameter['shareTo'] = shareTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1SetCommentForStepRequest} stepV1SetCommentForStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepNoauthServiceSetCommentForStep: async (id: string, stepV1SetCommentForStepRequest: StepV1SetCommentForStepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepNoauthServiceSetCommentForStep', 'id', id)
            // verify required parameter 'stepV1SetCommentForStepRequest' is not null or undefined
            assertParamExists('stepNoauthServiceSetCommentForStep', 'stepV1SetCommentForStepRequest', stepV1SetCommentForStepRequest)
            const localVarPath = `/apis/step-go-noauth/step/{id}/comment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1SetCommentForStepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StepNoauthServiceApi - functional programming interface
 * @export
 */
export const StepNoauthServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StepNoauthServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {StepV1DecryptRequest} stepV1DecryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepNoauthServiceDecrypt(id: string, stepV1DecryptRequest: StepV1DecryptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1DecryptReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepNoauthServiceDecrypt(id, stepV1DecryptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepNoauthServiceApi.stepNoauthServiceDecrypt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [shareTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepNoauthServiceGetNoauthStep(id: string, shareTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetNoauthStepReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepNoauthServiceGetNoauthStep(id, shareTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepNoauthServiceApi.stepNoauthServiceGetNoauthStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1SetCommentForStepRequest} stepV1SetCommentForStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepNoauthServiceSetCommentForStep(id: string, stepV1SetCommentForStepRequest: StepV1SetCommentForStepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1SetCommentForStepReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepNoauthServiceSetCommentForStep(id, stepV1SetCommentForStepRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepNoauthServiceApi.stepNoauthServiceSetCommentForStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StepNoauthServiceApi - factory interface
 * @export
 */
export const StepNoauthServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StepNoauthServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {StepV1DecryptRequest} stepV1DecryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepNoauthServiceDecrypt(id: string, stepV1DecryptRequest: StepV1DecryptRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1DecryptReply> {
            return localVarFp.stepNoauthServiceDecrypt(id, stepV1DecryptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [shareTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepNoauthServiceGetNoauthStep(id: string, shareTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetNoauthStepReply> {
            return localVarFp.stepNoauthServiceGetNoauthStep(id, shareTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1SetCommentForStepRequest} stepV1SetCommentForStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepNoauthServiceSetCommentForStep(id: string, stepV1SetCommentForStepRequest: StepV1SetCommentForStepRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1SetCommentForStepReply> {
            return localVarFp.stepNoauthServiceSetCommentForStep(id, stepV1SetCommentForStepRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StepNoauthServiceApi - object-oriented interface
 * @export
 * @class StepNoauthServiceApi
 * @extends {BaseAPI}
 */
export class StepNoauthServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {StepV1DecryptRequest} stepV1DecryptRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepNoauthServiceApi
     */
    public stepNoauthServiceDecrypt(id: string, stepV1DecryptRequest: StepV1DecryptRequest, options?: RawAxiosRequestConfig) {
        return StepNoauthServiceApiFp(this.configuration).stepNoauthServiceDecrypt(id, stepV1DecryptRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [shareTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepNoauthServiceApi
     */
    public stepNoauthServiceGetNoauthStep(id: string, shareTo?: string, options?: RawAxiosRequestConfig) {
        return StepNoauthServiceApiFp(this.configuration).stepNoauthServiceGetNoauthStep(id, shareTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {StepV1SetCommentForStepRequest} stepV1SetCommentForStepRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepNoauthServiceApi
     */
    public stepNoauthServiceSetCommentForStep(id: string, stepV1SetCommentForStepRequest: StepV1SetCommentForStepRequest, options?: RawAxiosRequestConfig) {
        return StepNoauthServiceApiFp(this.configuration).stepNoauthServiceSetCommentForStep(id, stepV1SetCommentForStepRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StepServiceApi - axios parameter creator
 * @export
 */
export const StepServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (for dir)
         * @param {string} id 
         * @param {StepV1AddTargetDirStepRequest} stepV1AddTargetDirStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceAddTargetDirStep: async (id: string, stepV1AddTargetDirStepRequest: StepV1AddTargetDirStepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceAddTargetDirStep', 'id', id)
            // verify required parameter 'stepV1AddTargetDirStepRequest' is not null or undefined
            assertParamExists('stepServiceAddTargetDirStep', 'stepV1AddTargetDirStepRequest', stepV1AddTargetDirStepRequest)
            const localVarPath = `/target/{id}/dir`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1AddTargetDirStepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StepV1CreateTargetRequest} stepV1CreateTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceCreateTarget: async (stepV1CreateTargetRequest: StepV1CreateTargetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stepV1CreateTargetRequest' is not null or undefined
            assertParamExists('stepServiceCreateTarget', 'stepV1CreateTargetRequest', stepV1CreateTargetRequest)
            const localVarPath = `/target`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1CreateTargetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceDeleteTarget: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceDeleteTarget', 'id', id)
            const localVarPath = `/target/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceDeleteTargetStep: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceDeleteTargetStep', 'id', id)
            const localVarPath = `/step/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1DoneTargetRequest} stepV1DoneTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceDoneTarget: async (id: string, stepV1DoneTargetRequest: StepV1DoneTargetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceDoneTarget', 'id', id)
            // verify required parameter 'stepV1DoneTargetRequest' is not null or undefined
            assertParamExists('stepServiceDoneTarget', 'stepV1DoneTargetRequest', stepV1DoneTargetRequest)
            const localVarPath = `/target/{id}/done`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1DoneTargetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1EncryptRequest} stepV1EncryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceEncrypt: async (id: string, stepV1EncryptRequest: StepV1EncryptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceEncrypt', 'id', id)
            // verify required parameter 'stepV1EncryptRequest' is not null or undefined
            assertParamExists('stepServiceEncrypt', 'stepV1EncryptRequest', stepV1EncryptRequest)
            const localVarPath = `/step/{id}/encrypt`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1EncryptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [withSteps] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTarget: async (id: string, withSteps?: boolean, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceGetTarget', 'id', id)
            const localVarPath = `/target/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (withSteps !== undefined) {
                localVarQueryParameter['withSteps'] = withSteps;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTargetDirStepChildren: async (id: string, page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceGetTargetDirStepChildren', 'id', id)
            const localVarPath = `/step/{id}/dir_children`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTargetTree: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceGetTargetTree', 'id', id)
            const localVarPath = `/target/{id}/tree`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [parentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTargets: async (parentId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/targets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1UpdateTargetRequest} stepV1UpdateTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceUpdateTarget: async (id: string, stepV1UpdateTargetRequest: StepV1UpdateTargetRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceUpdateTarget', 'id', id)
            // verify required parameter 'stepV1UpdateTargetRequest' is not null or undefined
            assertParamExists('stepServiceUpdateTarget', 'stepV1UpdateTargetRequest', stepV1UpdateTargetRequest)
            const localVarPath = `/target/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1UpdateTargetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1UpdateTargetStepRequest} stepV1UpdateTargetStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceUpdateTargetStep: async (id: string, stepV1UpdateTargetStepRequest: StepV1UpdateTargetStepRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stepServiceUpdateTargetStep', 'id', id)
            // verify required parameter 'stepV1UpdateTargetStepRequest' is not null or undefined
            assertParamExists('stepServiceUpdateTargetStep', 'stepV1UpdateTargetStepRequest', stepV1UpdateTargetStepRequest)
            const localVarPath = `/step/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepV1UpdateTargetStepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StepServiceApi - functional programming interface
 * @export
 */
export const StepServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StepServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * (for dir)
         * @param {string} id 
         * @param {StepV1AddTargetDirStepRequest} stepV1AddTargetDirStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceAddTargetDirStep(id: string, stepV1AddTargetDirStepRequest: StepV1AddTargetDirStepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1AddTargetDirStepReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceAddTargetDirStep(id, stepV1AddTargetDirStepRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceAddTargetDirStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {StepV1CreateTargetRequest} stepV1CreateTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceCreateTarget(stepV1CreateTargetRequest: StepV1CreateTargetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1CreateTargetReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceCreateTarget(stepV1CreateTargetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceCreateTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceDeleteTarget(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1DeleteTargetReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceDeleteTarget(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceDeleteTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceDeleteTargetStep(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1DeleteTargetStepReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceDeleteTargetStep(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceDeleteTargetStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1DoneTargetRequest} stepV1DoneTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceDoneTarget(id: string, stepV1DoneTargetRequest: StepV1DoneTargetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1DoneTargetReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceDoneTarget(id, stepV1DoneTargetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceDoneTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1EncryptRequest} stepV1EncryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceEncrypt(id: string, stepV1EncryptRequest: StepV1EncryptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1EncryptReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceEncrypt(id, stepV1EncryptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceEncrypt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [withSteps] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceGetTarget(id: string, withSteps?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetTargetReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceGetTarget(id, withSteps, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceGetTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceGetTargetDirStepChildren(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetTargetDirStepChildrenReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceGetTargetDirStepChildren(id, page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceGetTargetDirStepChildren']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceGetTargetTree(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetTargetTreeReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceGetTargetTree(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceGetTargetTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [parentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceGetTargets(parentId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1GetTargetsReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceGetTargets(parentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceGetTargets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1UpdateTargetRequest} stepV1UpdateTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceUpdateTarget(id: string, stepV1UpdateTargetRequest: StepV1UpdateTargetRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1UpdateTargetReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceUpdateTarget(id, stepV1UpdateTargetRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceUpdateTarget']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1UpdateTargetStepRequest} stepV1UpdateTargetStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stepServiceUpdateTargetStep(id: string, stepV1UpdateTargetStepRequest: StepV1UpdateTargetStepRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StepV1UpdateTargetStepReply>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stepServiceUpdateTargetStep(id, stepV1UpdateTargetStepRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StepServiceApi.stepServiceUpdateTargetStep']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StepServiceApi - factory interface
 * @export
 */
export const StepServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StepServiceApiFp(configuration)
    return {
        /**
         * (for dir)
         * @param {string} id 
         * @param {StepV1AddTargetDirStepRequest} stepV1AddTargetDirStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceAddTargetDirStep(id: string, stepV1AddTargetDirStepRequest: StepV1AddTargetDirStepRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1AddTargetDirStepReply> {
            return localVarFp.stepServiceAddTargetDirStep(id, stepV1AddTargetDirStepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StepV1CreateTargetRequest} stepV1CreateTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceCreateTarget(stepV1CreateTargetRequest: StepV1CreateTargetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1CreateTargetReply> {
            return localVarFp.stepServiceCreateTarget(stepV1CreateTargetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceDeleteTarget(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1DeleteTargetReply> {
            return localVarFp.stepServiceDeleteTarget(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceDeleteTargetStep(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1DeleteTargetStepReply> {
            return localVarFp.stepServiceDeleteTargetStep(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1DoneTargetRequest} stepV1DoneTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceDoneTarget(id: string, stepV1DoneTargetRequest: StepV1DoneTargetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1DoneTargetReply> {
            return localVarFp.stepServiceDoneTarget(id, stepV1DoneTargetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1EncryptRequest} stepV1EncryptRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceEncrypt(id: string, stepV1EncryptRequest: StepV1EncryptRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1EncryptReply> {
            return localVarFp.stepServiceEncrypt(id, stepV1EncryptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {boolean} [withSteps] 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTarget(id: string, withSteps?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetTargetReply> {
            return localVarFp.stepServiceGetTarget(id, withSteps, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTargetDirStepChildren(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetTargetDirStepChildrenReply> {
            return localVarFp.stepServiceGetTargetDirStepChildren(id, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTargetTree(id: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetTargetTreeReply> {
            return localVarFp.stepServiceGetTargetTree(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [parentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceGetTargets(parentId?: string, options?: RawAxiosRequestConfig): AxiosPromise<StepV1GetTargetsReply> {
            return localVarFp.stepServiceGetTargets(parentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1UpdateTargetRequest} stepV1UpdateTargetRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceUpdateTarget(id: string, stepV1UpdateTargetRequest: StepV1UpdateTargetRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1UpdateTargetReply> {
            return localVarFp.stepServiceUpdateTarget(id, stepV1UpdateTargetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StepV1UpdateTargetStepRequest} stepV1UpdateTargetStepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stepServiceUpdateTargetStep(id: string, stepV1UpdateTargetStepRequest: StepV1UpdateTargetStepRequest, options?: RawAxiosRequestConfig): AxiosPromise<StepV1UpdateTargetStepReply> {
            return localVarFp.stepServiceUpdateTargetStep(id, stepV1UpdateTargetStepRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StepServiceApi - object-oriented interface
 * @export
 * @class StepServiceApi
 * @extends {BaseAPI}
 */
export class StepServiceApi extends BaseAPI {
    /**
     * (for dir)
     * @param {string} id 
     * @param {StepV1AddTargetDirStepRequest} stepV1AddTargetDirStepRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceAddTargetDirStep(id: string, stepV1AddTargetDirStepRequest: StepV1AddTargetDirStepRequest, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceAddTargetDirStep(id, stepV1AddTargetDirStepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StepV1CreateTargetRequest} stepV1CreateTargetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceCreateTarget(stepV1CreateTargetRequest: StepV1CreateTargetRequest, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceCreateTarget(stepV1CreateTargetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceDeleteTarget(id: string, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceDeleteTarget(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceDeleteTargetStep(id: string, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceDeleteTargetStep(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {StepV1DoneTargetRequest} stepV1DoneTargetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceDoneTarget(id: string, stepV1DoneTargetRequest: StepV1DoneTargetRequest, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceDoneTarget(id, stepV1DoneTargetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {StepV1EncryptRequest} stepV1EncryptRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceEncrypt(id: string, stepV1EncryptRequest: StepV1EncryptRequest, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceEncrypt(id, stepV1EncryptRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {boolean} [withSteps] 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceGetTarget(id: string, withSteps?: boolean, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceGetTarget(id, withSteps, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceGetTargetDirStepChildren(id: string, page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceGetTargetDirStepChildren(id, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceGetTargetTree(id: string, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceGetTargetTree(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [parentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceGetTargets(parentId?: string, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceGetTargets(parentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {StepV1UpdateTargetRequest} stepV1UpdateTargetRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceUpdateTarget(id: string, stepV1UpdateTargetRequest: StepV1UpdateTargetRequest, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceUpdateTarget(id, stepV1UpdateTargetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {StepV1UpdateTargetStepRequest} stepV1UpdateTargetStepRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StepServiceApi
     */
    public stepServiceUpdateTargetStep(id: string, stepV1UpdateTargetStepRequest: StepV1UpdateTargetStepRequest, options?: RawAxiosRequestConfig) {
        return StepServiceApiFp(this.configuration).stepServiceUpdateTargetStep(id, stepV1UpdateTargetStepRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



